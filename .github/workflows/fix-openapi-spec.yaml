name: Fix OpenAPI Specification

on:
  issues:
    types: [opened, edited]

jobs:
  fix_spec:
    if: contains(github.event.issue.labels.*.name, 'spec-fix')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Parse issue form
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body;
            console.log('Issue body:', body);

            // Parse YAML form fields from GitHub issue body
            // GitHub forms create sections like "### Field Label\n\nValue"
            const rawUrlMatch = body.match(/### Raw URL\s*\n\n([^\n]+)/);
            const docUrlMatch = body.match(/### Documentation URL\s*\n\n([^\n]+)/);
            const fixContextMatch = body.match(/### Fix Context\s*\n\n([\s\S]*?)(?=\n### |$)/);
            const errorContextMatch = body.match(/### Error Context\s*\n\n([\s\S]*?)(?=\n### |$)/);

            const rawUrl = rawUrlMatch ? rawUrlMatch[1].trim() : '';
            const docUrl = docUrlMatch && docUrlMatch[1] !== '_No response_' ? docUrlMatch[1].trim() : '';
            const fixContext = fixContextMatch && fixContextMatch[1] !== '_No response_' ? fixContextMatch[1].trim() : '';
            const errorContext = errorContextMatch && errorContextMatch[1] !== '_No response_' ? errorContextMatch[1].trim() : '';

            console.log('Parsed values:', { rawUrl, docUrl, fixContext, errorContext });

            // Extract file path from raw URL for later use
            const urlPath = rawUrl.replace('https://raw.githubusercontent.com/', '').split('/');
            let startIndex = 3;
            if (urlPath[2] === 'refs' && urlPath[3] === 'heads') {
              startIndex = 5;
            }
            const filePath = urlPath.slice(startIndex).join('/');

            core.setOutput('raw_url', rawUrl);
            core.setOutput('doc_url', docUrl);
            core.setOutput('fix_context', fixContext);
            core.setOutput('error_context', errorContext);
            core.setOutput('file_path', filePath);

      - name: Validate inputs
        run: |
          if [ -z "${{ steps.parse.outputs.raw_url }}" ]; then
            echo "Error: Raw URL is required"
            exit 1
          fi
          if [[ "${{ steps.parse.outputs.raw_url }}" != https://raw.githubusercontent.com/* ]]; then
            echo "Error: URL must be a raw GitHub URL"
            exit 1
          fi
          if [[ "${{ steps.parse.outputs.raw_url }}" == *.yaml ]] || [[ "${{ steps.parse.outputs.raw_url }}" == *.yml ]]; then
            echo "Error: Only JSON format OpenAPI specifications are supported. YAML format is not supported."
            exit 1
          fi

      - name: Call OpenAPI Repair API
        id: api_call
        run: |
          # Create API request payload with all fields
          cat > request.json << EOF
          {
            "url": "${{ steps.parse.outputs.raw_url }}",
            "doc_url": "${{ steps.parse.outputs.doc_url }}",
            "fix_context": "${{ steps.parse.outputs.fix_context }}",
            "error_context": "${{ steps.parse.outputs.error_context }}"
          }
          EOF

          # Call the API
          response=$(curl -s -X POST "http://ec2-13-220-112-49.compute-1.amazonaws.com:8000/fix-url-spec" \
            -H "Content-Type: application/json" \
            -d @request.json)

          # Save full response for debugging
          echo "$response" > api_response.json

          # Extract repair details FIRST (before checking success)
          repair_details=$(echo "$response" | jq -c '.repair_details // null')
          if [ "$repair_details" != "null" ] && [ ! -z "$repair_details" ]; then
            echo "repair_details=$repair_details" >> $GITHUB_OUTPUT
          fi

          # Check if API call was successful
          success=$(echo "$response" | jq -r '.success // false')
          if [ "$success" != "true" ]; then
            echo "API call failed:"
            echo "$response" | jq -r '.message // "Unknown error"'
            # Don't exit 1 - let workflow continue to show repair details in comments
            echo "api_success=false" >> $GITHUB_OUTPUT
            rm -f request.json api_response.json
            exit 0
          fi

          # Save fixed spec
          echo "$response" | python3 -c 'import json; import sys; response = json.load(sys.stdin); json.dump(response.get("fixed_spec"), open("${{steps.parse.outputs.file_path }}", "w"), indent=2, ensure_ascii=True) if response.get("fixed_spec") else None'

          # Handle feedback.json - merge with existing if it exists
          if echo "$response" | jq -e '.feedback' > /dev/null; then
            # Extract new feedback from API response
            echo "$response" | jq -c '.feedback' > new_feedback.json
            
            # Get the directory where the spec file is located
            spec_dir=$(dirname "${{ steps.parse.outputs.file_path }}")
            feedback_file="$spec_dir/feedback.json"
            
            # Fix the repaired_file field in new feedback before merging
            actual_file_path="${{ steps.parse.outputs.file_path }}"
            jq --arg filepath "$actual_file_path" 'map(.repaired_file = $filepath)' new_feedback.json > new_feedback_fixed.json
            
            # Check if feedback.json already exists in that directory
            if [ -f "$feedback_file" ]; then
              echo "Existing feedback.json found at $feedback_file - merging..."
              # Merge: combine existing and new feedback arrays
              jq -s 'add' "$feedback_file" new_feedback_fixed.json > merged_feedback.json
              mv merged_feedback.json "$feedback_file"
            else
              echo "No existing feedback.json found - creating new one at $feedback_file..."
              mv new_feedback_fixed.json "$feedback_file"
            fi
            
            rm -f new_feedback.json
          fi

          echo "Fixed spec saved to: ${{ steps.parse.outputs.file_path }}"
          echo "Feedback saved to: feedback.json"
          rm -f request.json api_response.json
          echo "api_success=true" >> $GITHUB_OUTPUT

      - name: Create PR with changes
        id: create_pr
        if: steps.api_call.outputs.api_success == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          BRANCH_NAME="fix-spec-issue-${{ github.event.issue.number }}"
          git checkout -b "$BRANCH_NAME"
          git add .

          if git diff --cached --quiet; then
            echo "No changes to commit"
            echo "pr_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git commit -m "Fix OpenAPI spec from issue #${{ github.event.issue.number }}" \
            -m "- Fixed issues in OpenAPI specification" \
            -m "- URL: ${{ steps.parse.outputs.raw_url }}" \
            -m "- Doc URL: ${{ steps.parse.outputs.doc_url }}" \
            -m "- Fix Context: ${{ steps.parse.outputs.fix_context }}" \
            -m "- Error Context: ${{ steps.parse.outputs.error_context }}" \
            -m "" \
            -m "Resolves #${{ github.event.issue.number }}"

          git push origin "$BRANCH_NAME"

          cat > pr_body.md << 'EOF'
          ## ðŸ”§ OpenAPI Specification Fix

          This PR automatically fixes the OpenAPI specification from issue #${{ github.event.issue.number }}.

          ### ðŸ“‹ Details
          - **Source URL**: ${{ steps.parse.outputs.raw_url }}
          - **Documentation**: ${{ steps.parse.outputs.doc_url || 'Not provided' }}
          - **Fix Context**: ${{ steps.parse.outputs.fix_context || 'Not provided' }}
          - **Error Context**: ${{ steps.parse.outputs.error_context || 'Not provided' }}

          ### ðŸ¤– Changes Made
          - Applied automated fixes to the OpenAPI specification
          - Replaced original spec file with corrected version
          - Added feedback.json documenting all repairs

          ### âœ… Ready for Review
          This PR is ready for review and merging. All changes were generated by the OpenAPI-Repair service.

          Closes #${{ github.event.issue.number }}
          EOF

          gh pr create \
            --title "Fix OpenAPI spec from issue #${{ github.event.issue.number }}" \
            --body-file pr_body.md \
            --head "$BRANCH_NAME" \
            --base main \
            --label "automated-fix,spec-fix"

          echo "pr_created=true" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Comment on issue
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const apiSuccess = '${{ steps.api_call.outputs.api_success }}' === 'true';
            const prCreated = '${{ steps.create_pr.outputs.pr_created }}' === 'true';
            const repairDetails = ${{ toJSON(steps.api_call.outputs.repair_details) }};

            let emoji, title;
            if (!apiSuccess) {
              emoji = 'âŒ';
              title = 'OpenAPI specification fix failed';
            } else if (prCreated) {
              emoji = 'âœ…';
              title = 'OpenAPI specification fix completed successfully';
            } else {
              emoji = 'âœ…';
              title = 'OpenAPI specification analysis completed - no fixes needed';
            }

            const rawUrl = ${{ toJSON(steps.parse.outputs.raw_url) }};
            const docUrl = ${{ toJSON(steps.parse.outputs.doc_url) }} || 'None provided';
            const fixContext = ${{ toJSON(steps.parse.outputs.fix_context) }} || 'None provided';
            const errorContext = ${{ toJSON(steps.parse.outputs.error_context) }} || 'None provided';

            let resultMessage = '';
            let repairSection = '';

            if (apiSuccess && prCreated) {
              resultMessage = 'The specification has been analyzed and fixed. A pull request has been created with the changes.';
            } else if (apiSuccess && !prCreated) {
              resultMessage = 'The specification was processed but no changes were needed.';

              if (repairDetails) {
                try {
                  const repairs = JSON.parse(repairDetails);
                  repairSection = '\n**Analysis Results:**\n';
                  repairs.forEach(repair => {
                    if (repair.issue_description) {
                      repairSection += `- **${repair.type} Issue**: ${repair.issue_description}\n`;
                    }
                    if (repair.action_description || repair.action) {
                      const actionDesc = repair.action_description || repair.action;
                      repairSection += `- **${repair.type} Action**: ${actionDesc}\n`;
                    }
                  });
                  repairSection += '\n';
                } catch (e) {
                  console.log('Failed to parse repair details:', e);
                }
              }
            } else {
              resultMessage = 'There was an error processing the specification. Please check the workflow logs for details.';
              
              // Even if API failed, show repair details if available
              if (repairDetails) {
                try {
                  const repairs = JSON.parse(repairDetails);
                  repairSection = '\n**Analysis Results (Despite Failure):**\n';
                  repairs.forEach(repair => {
                    if (repair.issue_description) {
                      repairSection += `- **${repair.type} Issue**: ${repair.issue_description}\n`;
                    }
                    if (repair.action_description || repair.action) {
                      const actionDesc = repair.action_description || repair.action;
                      repairSection += `- **${repair.type} Action**: ${actionDesc}\n`;
                    }
                  });
                  repairSection += '\n';
                } catch (e) {
                  console.log('Failed to parse repair details:', e);
                }
              }
            }

            const comment = `${emoji} ${title}!

            **Processed URL:** ${rawUrl}
            **Documentation URL:** ${docUrl}
            **Fix Context:** ${fixContext}
            **Error Context:** ${errorContext}
            ${repairSection}
            ${resultMessage}

            ---
            *This comment was automatically generated by the OpenAPI Fix workflow.*`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });